.equ CBM_COLOUR_COUNT, 16

.equ INDEXED_COLOUR_COUNT_SIZE, 2

.equ SIZE_OF_UINT32_T, 4
.equ SIZE_OF_POINTER, 8
.equ SIZE_OF_PNG_PIXEL_DATA, 4
.equ SIZE_OF_VECTOR_DISTANCE, 8

.equ COLOUR_VECTOR_DISTANCES_TOTAL_SIZE, CBM_COLOUR_COUNT * SIZE_OF_VECTOR_DISTANCE

# enum colour_palette {
#   colour_palette_default  = 0,
#   colour_palette_pepto    = 1,
#   colour_palette_colodore = 2,
#   colour_palette_vice     = 3,
# };
.equ COLOUR_PALETTE_DEFAULT, 0x00
.equ COLOUR_PALETTE_PEPTO, 0x01
.equ COLOUR_PALETTE_COLODORE, 0x02
.equ COLOUR_PALETTE_VICE, 0x03
.equ DEFAULT_COLOUR_PALETTE, COLOUR_PALETTE_PEPTO

.equ DEFAULT_BACKGROUND_COLOUR, 0x00
.equ INCLUDE_BACKGROUND_COLOUR_COUNT, 0xff

.equ PEPTO_RGB_COLOUR_BLACK,       0x00000000
.equ PEPTO_RGB_COLOUR_WHITE,       0x00ffffff
.equ PEPTO_RGB_COLOUR_RED,         0x0068372b
.equ PEPTO_RGB_COLOUR_CYAN,        0x0070a4b2
.equ PEPTO_RGB_COLOUR_PURPLE,      0x006f3d86
.equ PEPTO_RGB_COLOUR_GREEN,       0x00588d43
.equ PEPTO_RGB_COLOUR_BLUE,        0x00352879
.equ PEPTO_RGB_COLOUR_YELLOW,      0x00b8c76f
.equ PEPTO_RGB_COLOUR_ORANGE,      0x006f4f25
.equ PEPTO_RGB_COLOUR_BROWN,       0x00433900
.equ PEPTO_RGB_COLOUR_LIGHT_RED,   0x009a6759
.equ PEPTO_RGB_COLOUR_DARK_GRAY,   0x00444444
.equ PEPTO_RGB_COLOUR_GRAY,        0x006c6c6c
.equ PEPTO_RGB_COLOUR_LIGHT_GREEN, 0x009ad284
.equ PEPTO_RGB_COLOUR_LIGHT_BLUE,  0x006c5eb5
.equ PEPTO_RGB_COLOUR_LIGHT_GRAY,  0x00959595

.equ COLODORE_RGB_COLOUR_BLACK,       0x00000000
.equ COLODORE_RGB_COLOUR_WHITE,       0x00ffffff
.equ COLODORE_RGB_COLOUR_RED,         0x00813338
.equ COLODORE_RGB_COLOUR_CYAN,        0x0075cec8
.equ COLODORE_RGB_COLOUR_PURPLE,      0x008e3c97
.equ COLODORE_RGB_COLOUR_GREEN,       0x0056ac4d
.equ COLODORE_RGB_COLOUR_BLUE,        0x002e2c9b
.equ COLODORE_RGB_COLOUR_YELLOW,      0x00edf171
.equ COLODORE_RGB_COLOUR_ORANGE,      0x008e5029
.equ COLODORE_RGB_COLOUR_BROWN,       0x00553800
.equ COLODORE_RGB_COLOUR_LIGHT_RED,   0x00c46c71
.equ COLODORE_RGB_COLOUR_DARK_GRAY,   0x004a4a4a
.equ COLODORE_RGB_COLOUR_GRAY,        0x007b7b7b
.equ COLODORE_RGB_COLOUR_LIGHT_GREEN, 0x00a9ff9f
.equ COLODORE_RGB_COLOUR_LIGHT_BLUE,  0x00706deb
.equ COLODORE_RGB_COLOUR_LIGHT_GRAY,  0x00b2b2b2

.equ VICE_RGB_COLOUR_BLACK,       0x000000
.equ VICE_RGB_COLOUR_WHITE,       0xfdfefc
.equ VICE_RGB_COLOUR_RED,         0xbe1a24
.equ VICE_RGB_COLOUR_CYAN,        0x30e6c6
.equ VICE_RGB_COLOUR_PURPLE,      0xb41ae2
.equ VICE_RGB_COLOUR_GREEN,       0x1fd21e
.equ VICE_RGB_COLOUR_BLUE,        0x211bae
.equ VICE_RGB_COLOUR_YELLOW,      0xdff60a
.equ VICE_RGB_COLOUR_ORANGE,      0xb84104
.equ VICE_RGB_COLOUR_BROWN,       0x6a3304
.equ VICE_RGB_COLOUR_LIGHT_RED,   0xfe4a57
.equ VICE_RGB_COLOUR_DARK_GRAY,   0x424540
.equ VICE_RGB_COLOUR_GRAY,        0x70746f
.equ VICE_RGB_COLOUR_LIGHT_GREEN, 0x59fe59
.equ VICE_RGB_COLOUR_LIGHT_BLUE,  0x5f53fe
.equ VICE_RGB_COLOUR_LIGHT_GRAY,  0xa4a7a2

.equ COLOUR_PALETTE_TOTAL_SIZE, CBM_COLOUR_COUNT * SIZE_OF_UINT32_T

.equ COLOUR_PALETTES_LENGTH, 3
.equ COLOUR_PALETTES_TOTAL_SIZE, COLOUR_PALETTES_LENGTH * SIZE_OF_POINTER

.equ CHAR_WIDTH, 0x08
.equ CHAR_HEIGHT, 0x08

.equ BITMAP_WIDTH, 0x0140
.equ BITMAP_HEIGHT, 0x00c8

.equ SCREEN_WIDTH, 0x0028
.equ SCREEN_HEIGHT, 0x0019

.equ BITMAP_DATA_LENGTH, 0x1f40
.equ SCREEN_DATA_LENGTH, 0x03e8

.equ SIZE_OF_BITMAP_ROW_DATA, 0x0140
.equ SIZE_OF_BITMAP_CHAR_DATA, 0x0008
.equ SIZE_OF_SCREEN_ROW_DATA, 0x0028

# struct Colour {
#   uint32_t rgb_value;
#   uint32_t original_rgb_value;
#   std::byte cbm_value;
# };
.equ COLOUR_RGB_VALUE_OFFSET, 0
.equ COLOUR_ORIGINAL_RGB_VALUE_OFFSET, 4
.equ COLOUR_CBM_VALUE_OFFSET, 8

.equ COLOUR_TOTAL_SIZE, 9

# struct ByteArray {
#   std::byte *data;
#   std::size_t length;
# };
.equ BYTE_ARRAY_DATA_OFFSET, 0
.equ BYTE_ARRAY_LENGTH_OFFSET, 8

.equ BYTE_ARRAY_TOTAL_SIZE, 16

# struct Bitmap {
#   std::byte *data;
# };
.equ BITMAP_DATA_OFFSET, 0

.equ BITMAP_TOTAL_SIZE, 8

# struct Screen {
#   std::byte *data;
# };
.equ SCREEN_DATA_OFFSET, 0

.equ SCREEN_TOTAL_SIZE, 8

# struct BaseImage {
#   ByteArray *bitmap_data_bytes;
#   ByteArray *screen_data_bytes;
#   Bitmap *bitmap;
#   Screen *screen;
# };
.equ BASE_IMAGE_BITMAP_DATA_BYTES_PTR_OFFSET, 0
.equ BASE_IMAGE_SCREEN_DATA_BYTES_PTR_OFFSET, 8
.equ BASE_IMAGE_BITMAP_PTR_OFFSET, 16
.equ BASE_IMAGE_SCREEN_PTR_OFFSET, 24

.equ BASE_IMAGE_TOTAL_SIZE, 32

# struct Hires {
#   BaseImage *base_image;
# };
.equ HIRES_BASE_IMAGE_PTR_OFFSET, 0

.equ HIRES_TOTAL_SIZE, 8

# struct HiresConfig {
#   char format_description[4];
#   uint16_t load_address;
#   uint16_t data_length;
#   uint16_t bitmap_offset;
#   uint16_t screen_offset;
# };
.equ HIRES_CONFIG_FORMAT_DESCRIPTION_OFFSET, 0
.equ HIRES_CONFIG_LOAD_ADDRESS_OFFSET, 4
.equ HIRES_CONFIG_DATA_LENGTH_OFFSET, 6
.equ HIRES_CONFIG_BITMAP_DATA_OFFSET, 8
.equ HIRES_CONFIG_SCREEN_DATA_OFFSET, 10

.equ HIRES_CONFIG_TOTAL_SIZE, 12

.equ ART_STUDIO_LOAD_ADDRESS, 0x2000
.equ ART_STUDIO_DATA_LENGTH, 0x232a
.equ ART_STUDIO_BITMAP_OFFSET, 0x0002
.equ ART_STUDIO_SCREEN_OFFSET, 0x1f42

# struct Multicolour {
#   BaseImage *base_image;
#   ByteArray *colours_data_bytes;
#   Screen *colours;
#   std::byte background_colour;
#   std::byte border_colour;
# };
.equ MULTICOLOUR_BASE_IMAGE_PTR_OFFSET, 0
.equ MULTICOLOUR_COLOURS_DATA_BYTES_PTR_OFFSET, 8
.equ MULTICOLOUR_COLOURS_PTR_OFFSET, 16
.equ MULTICOLOUR_BACKGROUND_COLOUR_OFFSET, 24
.equ MULTICOLOUR_BORDER_COLOUR_OFFSET, 25

.equ MULTICOLOUR_TOTAL_SIZE, 26

# struct MulticolourConfig {
#   char format_description[4];
#   uint16_t load_address;
#   uint16_t data_length;
#   uint16_t bitmap_offset;
#   uint16_t screen_offset;
#   uint16_t colours_offset;
#   uint16_t background_colour_offset;
#   uint16_t border_colour_offset;
# };
.equ MULTICOLOUR_CONFIG_FORMAT_DESCRIPTION_OFFSET, 0
.equ MULTICOLOUR_CONFIG_LOAD_ADDRESS_OFFSET, 4
.equ MULTICOLOUR_CONFIG_DATA_LENGTH_OFFSET, 6
.equ MULTICOLOUR_CONFIG_BITMAP_DATA_OFFSET, 8
.equ MULTICOLOUR_CONFIG_SCREEN_DATA_OFFSET, 10
.equ MULTICOLOUR_CONFIG_COLOURS_DATA_OFFSET, 12
.equ MULTICOLOUR_CONFIG_BACKGROUND_COLOUR_OFFSET, 14
.equ MULTICOLOUR_CONFIG_BORDER_COLOUR_OFFSET, 16

.equ MULTICOLOUR_CONFIG_TOTAL_SIZE, 18

.equ ADVANCED_ART_STUDIO_LOAD_ADDRESS, 0x2000
.equ ADVANCED_ART_STUDIO_DATA_LENGTH, 0x2722
.equ ADVANCED_ART_STUDIO_BITMAP_OFFSET, 0x0002
.equ ADVANCED_ART_STUDIO_SCREEN_OFFSET, 0x1f42
.equ ADVANCED_ART_STUDIO_COLOURS_OFFSET, 0x233a
.equ ADVANCED_ART_STUDIO_BACKGROUND_COLOUR_OFFSET, 0x232b
.equ ADVANCED_ART_STUDIO_BORDER_COLOUR_OFFSET, 0xffff

.equ FACEPAINTER_LOAD_ADDRESS, 0x4000
.equ FACEPAINTER_DATA_LENGTH, 0x2714
.equ FACEPAINTER_BITMAP_OFFSET, 0x0002
.equ FACEPAINTER_SCREEN_OFFSET, 0x1f42
.equ FACEPAINTER_COLOURS_OFFSET, 0x232a
.equ FACEPAINTER_BACKGROUND_COLOUR_OFFSET, 0x2713
.equ FACEPAINTER_BORDER_COLOUR_OFFSET, 0x2712

.equ KOALAPAINTER_LOAD_ADDRESS, 0x6000
.equ KOALAPAINTER_DATA_LENGTH, 0x2713
.equ KOALAPAINTER_BITMAP_OFFSET, 0x0002
.equ KOALAPAINTER_SCREEN_OFFSET, 0x1f42
.equ KOALAPAINTER_COLOURS_OFFSET, 0x232a
.equ KOALAPAINTER_BACKGROUND_COLOUR_OFFSET, 0x2712
.equ KOALAPAINTER_BORDER_COLOUR_OFFSET, 0xffff

# struct PixelMap {
#   Colour **colour_data;
#   uint16_t width;
#   uint16_t height;
#   enum colour_palette palette;
# };
.equ PIXELMAP_COLOUR_DATA_PTR_OFFSET, 0
.equ PIXELMAP_WIDTH_OFFSET, 8
.equ PIXELMAP_HEIGHT_OFFSET, 10
.equ PIXELMAP_COLOUR_PALETTE_OFFSET, 12

.equ PIXELMAP_TOTAL_SIZE, 13

# struct PngImport {
#   png_bytep *row_pointers;
#   uint32_t width;
#   uint32_t height;
#   ColourPalette *palette;
#   Byte background_colour;
# };
.equ PNG_IMPORT_ROW_POINTERS_OFFSET, 0
.equ PNG_IMPORT_WIDTH_OFFSET, 8
.equ PNG_IMPORT_HEIGHT_OFFSET, 12
.equ PNG_IMPORT_COLOUR_PALETTE_OFFSET, 16
.equ PNG_IMPORT_BACKGROUND_COLOUR_OFFSET, 24

.equ PNG_IMPORT_TOTAL_SIZE, 25
